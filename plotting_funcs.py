import Geometry
import forces
from math import sin, cos, asin, pi
import pandas as pd
import numpy as np
import altair as alt
from Enum_vals import Section, Member, Code, Run


def geom_plot_altair(force: forces.Forces, geom: Geometry.Geometry):
    """
    Plot the geometry of the chord and brace members including centerlines.
    """
    #Define key variables for brace
    length = 0.5 #length of brace member in metres that will be visible on graph on the diagonal
    br_top_x = length * cos(geom.theta) #horizontal projection of the brace length
    br_top_y = length * sin(geom.theta) #vertical projection of the brace length
    br_bot_left_x = geom.g_prime*geom.Dim_C.t/2.0 #bottom left intersect of brace with chord
    p = geom.Dim_B.d/sin(geom.theta) #horizontal slice width of brace (length of contact against chord)

    #Brace fill is generated by 2 parallel lines 'x' and 'x2'
    #brace1_x defines a linear array of numbers for the left line
    #(representing the left edge of the brace)
    #Then source is a dataframe that creates a similar length array of:
    #- 'x' - x-coord of left edge of brace
    #- 'x2' - x-coord of right edge of brace (+ projection)
    #- 'y' - y-coord of both lines above
    #- 'y_CL' - Centerline plot ending at intersection point
    #- 'y_CL_label' - Label value for centrline plot
    brace1_x = np.array([br_bot_left_x,br_bot_left_x+br_top_x])
    source = pd.DataFrame({'x':brace1_x,
                            'x2':brace1_x + p,
                            'x_CL':np.array([0, br_bot_left_x + br_top_x + p/2]),
                            'y_CL':np.array([-geom.e, geom.Dim_C.d/2 + br_top_y]),
                            'y_CL_label':np.array([f'{geom.theta*180/pi:.0f} deg','']),
                            'x_neg':-brace1_x,
                            'x2_neg':-brace1_x - p,
                            'x_neg_CL':np.array([0, -br_bot_left_x - br_top_x - p/2]),
                            'y':np.array([geom.Dim_C.d/2,geom.Dim_C.d/2+br_top_y])})

    #Altair mark_area function plots lines [x,y] and [x2,y] and fills horizontally
    #between both lines. An override color in HEX is provided for the fill.
    brace_area1 = alt.Chart(source).mark_area(opacity=0.6).encode(
        x = alt.X('x', scale=alt.Scale(domain=[-(geom.Dim_C.d+br_top_y)-0.4, (geom.Dim_C.d+br_top_y)+0.4])),
        x2='x2',
        y = alt.Y('y', scale=alt.Scale(domain=[-geom.Dim_C.d/2-0.2, geom.Dim_C.d/2+br_top_y+0.2])),
        color=alt.value("#0000FF")
        ).properties(title=f'Geometry of joint',width=600, height=300)
    brace_area2 = alt.Chart(source).mark_area(opacity=0.6).encode(
        x='x_neg',
        x2='x2_neg',
        y='y',
        color=alt.value("#0000FF")
        )

    #Plot brace centerlines using:
    #- x_CL & y_CL: coordinates of centerline line
    #- y_CL_label: angle label to be placed at bottom of line
    brace_CL1 = alt.Chart(source).mark_line().encode(
        x='x_CL',
        y='y_CL',
        strokeDash = alt.value([5, 5])
    )

    angle_text = alt.Chart(source).mark_text(align='left', dx=20).encode(
        x=alt.X('x_CL:Q',aggregate='min'),
        y=alt.Y('y_CL:Q', aggregate={'argmin': 'x_CL'}),
        text=alt.Text('y_CL_label:N',aggregate='min')
    )

    brace_CL2 = alt.Chart(source).mark_line().encode(
        x='x_neg_CL',
        y='y_CL',
        strokeDash = alt.value([5, 5])
    )
    #Altair configuration options for the graph title
    brace_area1.configure_title(
            fontSize=20,
            font='Courier',
            anchor='start',
            color='gray'
        )
    x_chord = br_bot_left_x + p + br_top_x
    source_chord = pd.DataFrame({'x':np.array([-x_chord,x_chord]),
                            'y':np.array([-geom.Dim_C.d/2,-geom.Dim_C.d/2]),
                            'y2':np.array([geom.Dim_C.d/2,geom.Dim_C.d/2])})
    chord_rect = alt.Chart(source_chord).mark_area(opacity=0.6).encode(
                                x='x',
                                y='y',
                                y2='y2',
                                color=alt.value("#FF0000")
    )

    #Unicode arrow codes are: ← → U-2190 U-2192 ⤾ ⤿ U-293e U-293f 
    Fx_left = 240
    Fx_right = 220
    a = {'x': [-(br_bot_left_x + br_top_x + p),
                    br_bot_left_x + br_top_x + p,
                    -(br_bot_left_x + br_top_x+ p/2),
                    br_bot_left_x + br_top_x+ p/2],
        'angle':[0.,0.,geom.theta*180/pi,180-geom.theta*180/pi],
        'y': [0.,0.,0.5,0.5],
        'name': [f'⤾ {force.M_ip_chord / 1000} kNm, {(force.P_chord - 2 * force.P_brace * cos(geom.theta))/1000:.2f} kN ←',
                    f'→ {force.P_chord / 1000:.2f} kN, ⤿ {force.M_ip_chord / 1000} kNm',
                    f'{force.P_brace / 1000:.2f} kN ←',
                    f'→ {force.P_brace / 1000:.2f} kN']}
    df_arrows = pd.DataFrame(a)

    arrow_1 = alt.Chart(df_arrows).encode(
        x='x',
        y='y',
        text='name')

    #The list comprehension for generating arrows at different angles is stated in:
    #https://stackoverflow.com/questions/55991996/altair-rotate-text-by-value-specified-in-feature
    arrow_layers = [
        arrow_1.transform_filter(alt.datum.name == name).mark_text(angle=angle,fontSize=15)
        for (name, angle) in zip(df_arrows.name, df_arrows.angle)]
    brace_area1.encoding.x.title = 'X (m)'
    brace_area1.encoding.y.title = 'Y (m)'

    #Where CHS is used, an arc should be plotted at the intersection of brace and chord.
    #Although not precise, this arc indicates the saddle of the circular sections on each other.
    if geom.Dim_C.section_type is Section.CHS:
        
        chord_overlap = 0.15

        #Algorithm to determine the equation of a circle via 3 points along it:
        #https://stackoverflow.com/questions/28910718/give-3-points-and-a-plot-circle
        #Complex numbers result in simpler calculations.
        #c = (negated) center of the circle
        #(as a complex number, so use .real and .imag for the x/y coordinates)
        #abs(c+x) = the radius (a real number, abs makes it so).
        #x,y,z are 3 points on the circle, converted into complex coordinates first
        #(x-coord = real part)(y-coord = complex part)
        x = complex(br_bot_left_x,geom.Dim_C.d/2)
        y = complex(br_bot_left_x + p/2,geom.Dim_C.d/2-chord_overlap*p)
        z = complex(br_bot_left_x + p,geom.Dim_C.d/2)
        w = z-x #intermediate value, no physical definition known
        w /= y-x
        c = (x-y)*(w-abs(w)**2)/2j/w.imag-x

        #Determine the angle subtended by an arc
        #asin(opp/hyp) is used because both opp & hyp are known
        #opp = p/2: half projected width of brace on chord represents 1/2 the subtended arc
        #hyp = abs(c+x) = radius: where radius is the hypotenuse of the triangle
        theta = asin((p/2)/abs(c+x))

        #Now that the subtended angle is obtained, need to create an array of 'num' values
        #between -theta and +theta which represents the entire angle range of arc
        #the angle is positioned around pi, which is equivalent to 180 deg with 0 deg being vertically up
        #therefore arc1_x represents the angles that make up the cradle of the brace.
        #The angles are then converted into coordinates along the curve link:
        #https://math.stackexchange.com/questions/260096/find-the-coordinates-of-a-point-on-a-circle
        #x = rsinθ + c[x], y = rcosθ + c[y] are for a circle centered at (c[x],c[y])
        #where c is defined above
        arc1_x = np.linspace(2*pi/2 - theta,2*pi/2 + theta,num=20)
        source_arc = pd.DataFrame({'x':abs(c+x)*np.sin(arc1_x)-c.real,
                                    'x_neg':-abs(c+x)*np.sin(arc1_x)+c.real,
                                    'y':abs(c+x)*np.cos(arc1_x)-c.imag,
                                    'y_horiz':geom.Dim_C.d/2})

        #Altair mark_area function plots lines [x,y] and [x,y_horiz] and fills vertically
        # y_horiz is simply y-coords along the interface of brace and chord (always geom.Dim_C.d/2)
        # x and y defined above               
        brace_arc1 = alt.Chart(source_arc).mark_area(opacity=0.6).encode(
            x='x',
            y='y',
            y2='y_horiz',
            color=alt.value("#0000FF")
            )
        brace_arc2 = alt.Chart(source_arc).mark_area(opacity=0.6).encode(
            x='x_neg',
            y='y',
            y2='y_horiz',
            color=alt.value("#0000FF")
            )
        return alt.layer(angle_text,brace_CL1,brace_CL2,chord_rect,brace_arc1,brace_arc2,brace_area1,brace_area2,*arrow_layers)
    else:
        #Where SHS or RHS, there is no arc needed because brace sits on top of chord and does not cradle it.
        return alt.layer(angle_text,brace_CL1,brace_CL2,chord_rect,brace_area1,brace_area2,*arrow_layers)