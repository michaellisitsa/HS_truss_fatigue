import streamlit as st

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.lines as lines
import altair as alt

#Bokeh Plots
from bokeh.plotting import figure
from bokeh.models import ColumnDataSource, CustomJS, Label

# import function
from streamlit_bokeh_events import streamlit_bokeh_events

import forallpeople as u
u.environment('structural')
import math

def dim_params_altair(val1_string,val1,val2_string,val2,param_string,min,max,x_max):
    """
    Plot the dimensional variables beta, 
    2*gamma and tau, showing the acceptable range in green highlighted area
    """
    x = np.array([0,x_max])
    source = pd.DataFrame({
            val1_string: x,
            'y_max': x * max,
            'y_min': x * min
            })
    source_points = pd.DataFrame({
            val1_string:val1,
            val2_string:val2},index=[0])
    area = alt.Chart(source).mark_area(opacity=0.3).encode(
        x=val1_string,
        y='y_min',
        y2='y_max',
        color=alt.value("#33bd81")
        ).properties(title=f'{min} <= {param_string}(={val2_string}/{val1_string}) <= {max}')
    points = alt.Chart(source_points).mark_point(size=80).encode(
        x=val1_string,
        y=val2_string
    )
    c = alt.layer(points,area)
    c.layer[0].encoding.y.title = val2_string + ' (mm)'
    c.layer[0].encoding.x.title = val1_string + ' (mm)'
    c.configure_title(
                fontSize=20,
                font='Courier',
                anchor='start',
                color='gray'
            )
    return c

def bar_chart_altair(sigma_chord1P,
                sigma_chord2P,
                sigma_chordM_ip,
                sigma_chordM_op,
                sigma_brace_1P,
                sigma_braceM_op,
                sigma_max):
    source = pd.DataFrame({'member':['chord','brace','chord','chord','chord','brace'],
                    'stress_type':['sigma_1P','sigma_1P','sigma_2P','sigma_M_ip','sigma_M_op','sigma_M_op'],
                    'stress':[sigma_chord1P,sigma_brace_1P,sigma_chord2P,sigma_chordM_ip,sigma_chordM_op,sigma_braceM_op]})
    bars = alt.Chart(source).mark_bar().encode(
        x=alt.X('sum(stress):Q', stack='zero'),
        y=alt.Y('member:N'),
        color=alt.Color('stress_type')).properties(height=200)

    text = alt.Chart(source).mark_text(dx=-15, dy=3, color='white').encode(
        x=alt.X('sum(stress):Q', stack='zero'),
        y=alt.Y('member:N'),
        detail='stress_type:N',
        text=alt.Text('sum(stress):Q', format='.1f')
    )
    limit = alt.Chart(pd.DataFrame({'x': [24]})).mark_rule(color='red').encode(
        x='x'
    )
    
    return bars + text + limit

def geom_plot_altair(h0,theta,g_prime,t0,h1,e,chord_type):
    """
    Plot the geometry of the chord and brace members including centerlines.
    """
    #Define key variables for brace
    length = 0.5 #length of brace member in metres that will be visible on graph on the diagonal
    br_top_x = length * math.cos(theta) #horizontal projection of the brace length
    br_top_y = length * math.sin(theta) #vertical projection of the brace length
    br_bot_left_x = g_prime*t0/2.0 #bottom left intersect of brace with chord
    p = h1/math.sin(theta) #horizontal slice width of brace (length of contact against chord)

    #Brace fill is generated by 2 parallel lines 'x' and 'x2'
    #brace1_x defines a linear array of numbers for the left line
    #(representing the left edge of the brace)
    #Then source is a dataframe that creates a similar length array of:
    #- 'x' - x-coord of left edge of brace
    #- 'x2' - x-coord of right edge of brace (+ projection)
    #- 'y' - y-coord of both lines above
    #- 'y_CL' - Centerline plot ending at intersection point
    #- 'y_CL_label' - Label value for centrline plot
    brace1_x = np.array([br_bot_left_x,br_bot_left_x+br_top_x])
    source = pd.DataFrame({'x':brace1_x,
                            'x2':brace1_x + p,
                            'x_CL':np.array([0, br_bot_left_x + br_top_x + p/2]),
                            'y_CL':np.array([-e, h0/2 + br_top_y]),
                            'y_CL_label':np.array([f'{theta*180/math.pi:.0f} deg','']),
                            'x_neg':-brace1_x,
                            'x2_neg':-brace1_x - p,
                            'x_neg_CL':np.array([0, -br_bot_left_x - br_top_x - p/2]),
                            'y':np.array([h0/2,h0/2+br_top_y])})

    #Altair mark_area function plots lines [x,y] and [x2,y] and fills horizontally
    #between both lines. An override color in HEX is provided for the fill.
    brace_area1 = alt.Chart(source).mark_area(opacity=0.6).encode(
        x = alt.X('x', scale=alt.Scale(domain=[-(h0+br_top_y)-0.4, (h0+br_top_y)+0.4])),
        x2='x2',
        y = alt.Y('y', scale=alt.Scale(domain=[-h0/2-0.2, h0/2+br_top_y+0.2])),
        color=alt.value("#0000FF")
        ).properties(title=f'Geometry of joint',width=600, height=300)
    brace_area2 = alt.Chart(source).mark_area(opacity=0.6).encode(
        x='x_neg',
        x2='x2_neg',
        y='y',
        color=alt.value("#0000FF")
        )

    brace_CL1 = alt.Chart(source).mark_line().encode(
        x='x_CL',
        y='y_CL',
        strokeDash = alt.value([5, 5])
    )

    angle_text = alt.Chart(source).mark_text(align='left', dx=20).encode(
        x=alt.X('x_CL:Q',aggregate='min'),
         y=alt.Y('y_CL:Q', aggregate={'argmin': 'x_CL'}),
         text=alt.Text('y_CL_label:N',aggregate='min')
    )

    brace_CL2 = alt.Chart(source).mark_line().encode(
        x='x_neg_CL',
        y='y_CL',
        strokeDash = alt.value([5, 5])
    )
    #Altair configuration options for the graph title
    brace_area1.configure_title(
            fontSize=20,
            font='Courier',
            anchor='start',
            color='gray'
        )
    x_chord = br_bot_left_x + p + br_top_x
    source_chord = pd.DataFrame({'x':np.array([-x_chord,x_chord]),
                            'y':np.array([-h0/2,-h0/2]),
                            'y2':np.array([h0/2,h0/2])})
    chord_rect = alt.Chart(source_chord).mark_area(opacity=0.6).encode(
                                x='x',
                                y='y',
                                y2='y2',
                                color=alt.value("#FF0000")
    )
    
    # annotation = alt.Chart().mark_text(
    # align='left',
    # baseline='middle',
    # fontSize = 20,
    # dx = 7
    # ).encode(
    #     x=[0.],
    #     y=[-e],
    #     text=f'{theta*180/math.pi}')

    #Where CHS is used, an arc should be plotted at the intersection of brace and chord.
    #Although not precise, this arc indicates the saddle of the circular sections on each other.
    if chord_type=="CHS":
        
        chord_overlap = 0.15

        #Algorithm to determine the equation of a circle via 3 points along it:
        #https://stackoverflow.com/questions/28910718/give-3-points-and-a-plot-circle
        #Complex numbers result in simpler calculations.
        #c = (negated) center of the circle
        #(as a complex number, so use .real and .imag for the x/y coordinates)
        #abs(c+x) = the radius (a real number, abs makes it so).
        #x,y,z are 3 points on the circle, converted into complex coordinates first
        #(x-coord = real part)(y-coord = complex part)
        x = complex(br_bot_left_x,h0/2)
        y = complex(br_bot_left_x + p/2,h0/2-chord_overlap*p)
        z = complex(br_bot_left_x + p,h0/2)
        w = z-x #intermediate value, no physical definition known
        w /= y-x
        c = (x-y)*(w-abs(w)**2)/2j/w.imag-x

        #Determine the angle subtended by an arc
        #asin(opp/hyp) is used because both opp & hyp are known
        #opp = p/2: half projected width of brace on chord represents 1/2 the subtended arc
        #hyp = abs(c+x) = radius: where radius is the hypotenuse of the triangle
        theta = math.asin((p/2)/abs(c+x))

        #Now that the subtended angle is obtained, need to create an array of 'num' values
        #between -theta and +theta which represents the entire angle range of arc
        #the angle is positioned around pi, which is equivalent to 180 deg with 0 deg being vertically up
        #therefore arc1_x represents the angles that make up the cradle of the brace.
        #The angles are then converted into coordinates along the curve link:
        #https://math.stackexchange.com/questions/260096/find-the-coordinates-of-a-point-on-a-circle
        #x = rsinθ + c[x], y = rcosθ + c[y] are for a circle centered at (c[x],c[y])
        #where c is defined above
        arc1_x = np.linspace(2*math.pi/2 - theta,2*math.pi/2 + theta,num=20)
        source_arc = pd.DataFrame({'x':abs(c+x)*np.sin(arc1_x)-c.real,
                                    'x_neg':-abs(c+x)*np.sin(arc1_x)+c.real,
                                    'y':abs(c+x)*np.cos(arc1_x)-c.imag,
                                    'y_horiz':h0/2})

        #Altair mark_area function plots lines [x,y] and [x,y_horiz] and fills vertically
        # y_horiz is simply y-coords along the interface of brace and chord (always h0/2)
        # x and y defined above               
        brace_arc1 = alt.Chart(source_arc).mark_area(opacity=0.6).encode(
            x='x',
            y='y',
            y2='y_horiz',
            color=alt.value("#0000FF")
            )
        brace_arc2 = alt.Chart(source_arc).mark_area(opacity=0.6).encode(
            x='x_neg',
            y='y',
            y2='y_horiz',
            color=alt.value("#0000FF")
            )
        return  angle_text + brace_CL1 + brace_CL2 + chord_rect + brace_arc1 + brace_arc2 + brace_area1 + brace_area2
    else:
        #Where SHS or RHS, there is no arc needed because brace sits on top of chord and does not cradle it.
        return  angle_text + brace_CL1 + brace_CL2 + chord_rect + brace_area1 + brace_area2

def SCF_ochax_plot(beta,SCF_ochax,SCF_obax):
    #Create graph to visualise answer on graph
    fig, ax = plt.subplots(1,2)
    SCF_ochax_img = plt.imread("data/SCFochax.png")
    SCF_obax_img = plt.imread("data/SCFobax.png")
    ax[0].imshow(SCF_ochax_img, extent=[0, 1, 0, 4])
    ax[1].imshow(SCF_obax_img, extent=[0, 1, 0, 4])
    ax[0].set_title(r"$SCF_{o,ch,ax}$")
    ax[1].set_title(r"$SCF_{o,b,ax}$")
    ax[0].plot(beta,SCF_ochax,'ro')
    ax[1].plot(beta,SCF_obax,'ro')
    ax[0].set_aspect(0.25)
    ax[1].set_aspect(0.25)
    return fig, ax

def bokeh_interactive(sigma_chord,sigma_brace,sigma_max,chord_ind,brace_ind):
    # create plot
    p = figure(tools="lasso_select,reset",
                x_range=(0, sigma_max*3), 
                y_range=(0, sigma_max*3),
                x_axis_label='Chord Stress (MPa)',
                y_axis_label='Brace Stress (MPa)')
    cds = ColumnDataSource(
        data={
            "x": sigma_chord,
            "y": sigma_brace,
        }
    )
    p.circle("x", "y", source=cds)

    # define events
    cds.selected.js_on_change(
        "indices",
        CustomJS(
            args=dict(source=cds),
            code="""
            document.dispatchEvent(
                new CustomEvent("TestSelectEvent", {detail: {indices: cb_obj.indices}})
            )
            """
        )
    )

    # result will be a dict of {event_name: event.detail}
    # events by default is "", in case of more than one events pass it as a comma separated values
    # event1,event2 
    # debounce is in ms
    # refresh_on_update should be set to False only if we dont want to update datasource at runtime
    # override_height overrides the viewport height
    result = streamlit_bokeh_events(
            bokeh_plot=p,
            events="TestSelectEvent",
            key="foo",
            refresh_on_update=True,
            override_height=600,
            debounce_time=500)
    # some event was thrown
    if result is not None:
        # TestSelectEvent was thrown
        if "TestSelectEvent" in result:
            st.subheader("Selected Points")
            indices = result["TestSelectEvent"].get("indices", [])
            col1, col2 = st.beta_columns(2)
            col1.subheader("Chords")
            col1.table([chord_ind[i] for i in indices])
            col2.subheader("Brace")
            col2.table([brace_ind[i] for i in indices])